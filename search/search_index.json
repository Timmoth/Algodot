{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DsaDotnet A collection of algorithms and datastructures implemented in dotnet. If you can think of a way to improve any of the existing implementations feel free to open a PR and see if you can beat my benchmarks! Support \ud83d\udedf Need help? Ping me on linkedin and I'd be more then happy to jump on a call to debug, help configure or answer any questions.","title":"Overview \u2705"},{"location":"#dsadotnet","text":"A collection of algorithms and datastructures implemented in dotnet. If you can think of a way to improve any of the existing implementations feel free to open a PR and see if you can beat my benchmarks!","title":"DsaDotnet"},{"location":"#support","text":"Need help? Ping me on linkedin and I'd be more then happy to jump on a call to debug, help configure or answer any questions.","title":"Support \ud83d\udedf"},{"location":"benchmarks/","text":"Each push to main triggers the benchmarks to be ran and compared against the previous version, you can see them here Run all the benchmarks locally dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release --job short --filter '*' --memory --join Run a specific set of benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release --job short --memory --f *Fibonacci*","title":"Benchmarks \u23f1\ufe0f"},{"location":"contributing/","text":"Contributing \ud83d\ude4f Contributions are welcome! Here\u2019s how you can get involved: Fork the repository : Click the \"Fork\" button at the top right of this page. Clone your fork : bash git clone https://github.com/Timmoth/DsaDotnet.git Create a branch : Make your changes in a new branch. bash git checkout -b my-feature-branch Commit your changes : bash git commit -m 'Add some feature' Push to the branch : bash git push origin my-feature-branch Open a pull request : Describe your changes and submit your PR.","title":"Contributing \ud83d\ude4f"},{"location":"contributing/#contributing","text":"Contributions are welcome! Here\u2019s how you can get involved: Fork the repository : Click the \"Fork\" button at the top right of this page. Clone your fork : bash git clone https://github.com/Timmoth/DsaDotnet.git Create a branch : Make your changes in a new branch. bash git checkout -b my-feature-branch Commit your changes : bash git commit -m 'Add some feature' Push to the branch : bash git push origin my-feature-branch Open a pull request : Describe your changes and submit your PR.","title":"Contributing \ud83d\ude4f"},{"location":"releases/","text":"Version Description 8.0.4 Added KVP Tree 8.0.3 Added Text algorithms 8.0.2 Added Geometry data structures 8.0.1 Added XML docs 8.0.0 Initial release","title":"Releases \ud83d\udcd2"},{"location":"tests/","text":"All tests must pass before a PR can be merged into main. Run all the tests locally dotnet test I use Stryker mutation testing to help identify missing tests View the Stryker report here dotnet tool install --global dotnet-stryker dotnet-stryker Running Stryker will output a report outlining which mutations (essentially bugs) were introduced into your code that did not cause any tests to fail.","title":"Tests \ud83d\udc1e"},{"location":"Arithmetic/greatest_common_divisor/","text":"The largest positive integer that divides two or more numbers without leaving a remainder. Implementation Usage var result = Arithmetic.GCD(10, 20); Tests","title":"Greatest Common Divisor"},{"location":"Arithmetic/greatest_common_divisor/#implementation","text":"","title":"Implementation"},{"location":"Arithmetic/greatest_common_divisor/#usage","text":"var result = Arithmetic.GCD(10, 20);","title":"Usage"},{"location":"Arithmetic/greatest_common_divisor/#tests","text":"","title":"Tests"},{"location":"Arithmetic/least_common_multiple/","text":"The smallest positive integer that is a multiple of two or more numbers. Implementation Usage var result = Arithmetic.LCM(10, 20); result = Arithmetic.LCM(10, 20, 30); Tests","title":"Least Common Multiple"},{"location":"Arithmetic/least_common_multiple/#implementation","text":"","title":"Implementation"},{"location":"Arithmetic/least_common_multiple/#usage","text":"var result = Arithmetic.LCM(10, 20); result = Arithmetic.LCM(10, 20, 30);","title":"Usage"},{"location":"Arithmetic/least_common_multiple/#tests","text":"","title":"Tests"},{"location":"DataStructures/binary_tree/","text":"A hierarchical data structure composed of nodes. Each node can have a left and right child node where left node is less than and the right node is greater than the parent node. Implementation Usage var tree = new BinaryTree<int>(); tree.Insert(0, 1, 2, 3); var node = tree.Search(2); Tests","title":"Binary Tree"},{"location":"DataStructures/binary_tree/#implementation","text":"","title":"Implementation"},{"location":"DataStructures/binary_tree/#usage","text":"var tree = new BinaryTree<int>(); tree.Insert(0, 1, 2, 3); var node = tree.Search(2);","title":"Usage"},{"location":"DataStructures/binary_tree/#tests","text":"","title":"Tests"},{"location":"DataStructures/kvp_binary_tree/","text":"Implementation","title":"Kvp Binary Tree"},{"location":"DataStructures/kvp_binary_tree/#implementation","text":"","title":"Implementation"},{"location":"DataStructures/unweighted_graph/","text":"A collection of vertices connected by edges. Implementation Usage var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); Tests","title":"Unweighted Graph"},{"location":"DataStructures/unweighted_graph/#implementation","text":"","title":"Implementation"},{"location":"DataStructures/unweighted_graph/#usage","text":"var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3));","title":"Usage"},{"location":"DataStructures/unweighted_graph/#tests","text":"","title":"Tests"},{"location":"DataStructures/weighted_graph/","text":"A collection of vertices connected by edges, where each edge has an associated weight. Implementation Usage var graph = new WeightedGraph<int>(); graph.AddEdges(new []{(0, 1), (1, 2), (2, 3)}, 1); graph.AddEdges((3, 4, 1), (4, 5, 1)); Tests","title":"Weighted Graph"},{"location":"DataStructures/weighted_graph/#implementation","text":"","title":"Implementation"},{"location":"DataStructures/weighted_graph/#usage","text":"var graph = new WeightedGraph<int>(); graph.AddEdges(new []{(0, 1), (1, 2), (2, 3)}, 1); graph.AddEdges((3, 4, 1), (4, 5, 1));","title":"Usage"},{"location":"DataStructures/weighted_graph/#tests","text":"","title":"Tests"},{"location":"Geometry/Regular_Polygon/","text":"Implementation","title":"Regular Polygon"},{"location":"Geometry/Regular_Polygon/#implementation","text":"","title":"Implementation"},{"location":"Geometry/circle/","text":"Implementation Usage var a = new Circle(Vector2.One, 1.0f); var b = new Circle(Vector2.Zero, 1.0f); var intersects = a.Intersects(b); Tests","title":"Circle"},{"location":"Geometry/circle/#implementation","text":"","title":"Implementation"},{"location":"Geometry/circle/#usage","text":"var a = new Circle(Vector2.One, 1.0f); var b = new Circle(Vector2.Zero, 1.0f); var intersects = a.Intersects(b);","title":"Usage"},{"location":"Geometry/circle/#tests","text":"","title":"Tests"},{"location":"Geometry/ellipse/","text":"Implementation","title":"Ellipse"},{"location":"Geometry/ellipse/#implementation","text":"","title":"Implementation"},{"location":"Geometry/polygon/","text":"Implementation","title":"Polygon"},{"location":"Geometry/polygon/#implementation","text":"","title":"Implementation"},{"location":"Geometry/polyline/","text":"Implementation","title":"Polyline"},{"location":"Geometry/polyline/#implementation","text":"","title":"Implementation"},{"location":"Geometry/rectangle/","text":"Implementation Usage var a = new Rectangle(Vector2.One, Vector2.One); var b = new Rectangle(Vector2.Zero, Vector2.One); var intersects = a.Intersects(b);","title":"Rectangle"},{"location":"Geometry/rectangle/#implementation","text":"","title":"Implementation"},{"location":"Geometry/rectangle/#usage","text":"var a = new Rectangle(Vector2.One, Vector2.One); var b = new Rectangle(Vector2.Zero, Vector2.One); var intersects = a.Intersects(b);","title":"Usage"},{"location":"Geometry/triangle/","text":"Implementation Usage var a = new Triangle(Vector2.One, Vector2.UnitX, Vector2.UnitY); var b = new Triangle(Vector2.Zero, Vector2.One, Vector2.UnitX); var intersects = a.Intersects(b);","title":"Triangle"},{"location":"Geometry/triangle/#implementation","text":"","title":"Implementation"},{"location":"Geometry/triangle/#usage","text":"var a = new Triangle(Vector2.One, Vector2.UnitX, Vector2.UnitY); var b = new Triangle(Vector2.Zero, Vector2.One, Vector2.UnitX); var intersects = a.Intersects(b);","title":"Usage"},{"location":"Search/binary_search/","text":"Find a value within a sorted array by dividing the search interval in half at each step. Implementation Usage var index = new []{ 1, 2, 3}.BinarySearch(2); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *BinarySearch* Tests","title":"Binary"},{"location":"Search/binary_search/#implementation","text":"","title":"Implementation"},{"location":"Search/binary_search/#usage","text":"var index = new []{ 1, 2, 3}.BinarySearch(2);","title":"Usage"},{"location":"Search/binary_search/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *BinarySearch*","title":"Benchmarks"},{"location":"Search/binary_search/#tests","text":"","title":"Tests"},{"location":"Search/breadth_first_search/","text":"Explore all neighbor nodes at the present depth before moving on to nodes at the next depth level. Implementation Usage var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var node = graph.BreadthFirstSearch(0, n => n.Key == 3); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Bfs* Tests","title":"Breadth first"},{"location":"Search/breadth_first_search/#implementation","text":"","title":"Implementation"},{"location":"Search/breadth_first_search/#usage","text":"var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var node = graph.BreadthFirstSearch(0, n => n.Key == 3);","title":"Usage"},{"location":"Search/breadth_first_search/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Bfs*","title":"Benchmarks"},{"location":"Search/breadth_first_search/#tests","text":"","title":"Tests"},{"location":"Search/depth_first_search/","text":"Explore as far as possible along each branch before backtracking. Implementation Usage var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var node = graph.DepthFirstSearch(0, n => n.Key == 3); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Dfs* Tests","title":"Depth First"},{"location":"Search/depth_first_search/#implementation","text":"","title":"Implementation"},{"location":"Search/depth_first_search/#usage","text":"var graph = new UnWeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var node = graph.DepthFirstSearch(0, n => n.Key == 3);","title":"Usage"},{"location":"Search/depth_first_search/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Dfs*","title":"Benchmarks"},{"location":"Search/depth_first_search/#tests","text":"","title":"Tests"},{"location":"Search/djikstras/","text":"Find the shortest path between nodes in a graph with non-negative edge weights, by iteratively selecting the node with the minimum distance from the starting node and updating distances to adjacent nodes. Implementation Usage var graph = new WeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var path = graph.Dijkstra(0, n => n.Key == 3); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Dijkstra* Tests","title":"Djikstras"},{"location":"Search/djikstras/#implementation","text":"","title":"Implementation"},{"location":"Search/djikstras/#usage","text":"var graph = new WeightedGraph<int>(); graph.AddEdges((0, 1), (1, 2), (2, 3)); var path = graph.Dijkstra(0, n => n.Key == 3);","title":"Usage"},{"location":"Search/djikstras/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Dijkstra*","title":"Benchmarks"},{"location":"Search/djikstras/#tests","text":"","title":"Tests"},{"location":"Search/linear_search/","text":"Iterate through each element sequentially from the start until the end until the desired element is found. Implementation Usage var index = new []{ 1, 2, 3}.LinearSearch(2); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *LinearSearch* Tests","title":"Linear"},{"location":"Search/linear_search/#implementation","text":"","title":"Implementation"},{"location":"Search/linear_search/#usage","text":"var index = new []{ 1, 2, 3}.LinearSearch(2);","title":"Usage"},{"location":"Search/linear_search/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *LinearSearch*","title":"Benchmarks"},{"location":"Search/linear_search/#tests","text":"","title":"Tests"},{"location":"SequenceAndSeries/factorial/","text":"Denoted by n!, the factorial of an unsigned integer is the product of all integers less then or equal to n. Implementation n! = n * (n-1) * (n-2) * ... * 3 * 2 * 1 0! = 1 1! = 1 2! = 2 3! = 6 Usage ulong result = Series.Factorial(1000); result = 1000.Factorial(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Factorial* Tests","title":"Factorial"},{"location":"SequenceAndSeries/factorial/#implementation","text":"n! = n * (n-1) * (n-2) * ... * 3 * 2 * 1 0! = 1 1! = 1 2! = 2 3! = 6","title":"Implementation"},{"location":"SequenceAndSeries/factorial/#usage","text":"ulong result = Series.Factorial(1000); result = 1000.Factorial();","title":"Usage"},{"location":"SequenceAndSeries/factorial/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Factorial*","title":"Benchmarks"},{"location":"SequenceAndSeries/factorial/#tests","text":"","title":"Tests"},{"location":"SequenceAndSeries/fibonacci/","text":"A sequence where each term is the sum of the two preceding terms, starting with 0 and 1. Implementation f(0) = 0 f(1) = 1 f(n) = f(n-1) + f(n-2) 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ... Usage ulong result = Series.Fibonacci(1000); result = 1000.Fibonacci(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Fibonacci* Tests","title":"Fibonacci"},{"location":"SequenceAndSeries/fibonacci/#implementation","text":"f(0) = 0 f(1) = 1 f(n) = f(n-1) + f(n-2) 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...","title":"Implementation"},{"location":"SequenceAndSeries/fibonacci/#usage","text":"ulong result = Series.Fibonacci(1000); result = 1000.Fibonacci();","title":"Usage"},{"location":"SequenceAndSeries/fibonacci/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Fibonacci*","title":"Benchmarks"},{"location":"SequenceAndSeries/fibonacci/#tests","text":"","title":"Tests"},{"location":"SequenceAndSeries/primes/","text":"Unsigned integers greater than 1 that have no positive divisors other than 1 and themselves. Implementation 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 Usage List<int> result = Series.PrimesUpTo(1000); result = 1000.PrimesUpTo(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Primes* Tests","title":"Primes"},{"location":"SequenceAndSeries/primes/#implementation","text":"2, 3, 5, 7, 11, 13, 17, 19, 23, 29","title":"Implementation"},{"location":"SequenceAndSeries/primes/#usage","text":"List<int> result = Series.PrimesUpTo(1000); result = 1000.PrimesUpTo();","title":"Usage"},{"location":"SequenceAndSeries/primes/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *Primes*","title":"Benchmarks"},{"location":"SequenceAndSeries/primes/#tests","text":"","title":"Tests"},{"location":"Sorting/bubble_sort/","text":"Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order, continuing until the list is sorted. Implementation Usage List<int> result = new[] { 5, 4, 3, 2, 1 }.BubbleSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.BubbleSortInPlace(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *BubbleSort* Tests","title":"Bubble"},{"location":"Sorting/bubble_sort/#implementation","text":"","title":"Implementation"},{"location":"Sorting/bubble_sort/#usage","text":"List<int> result = new[] { 5, 4, 3, 2, 1 }.BubbleSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.BubbleSortInPlace();","title":"Usage"},{"location":"Sorting/bubble_sort/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *BubbleSort*","title":"Benchmarks"},{"location":"Sorting/bubble_sort/#tests","text":"","title":"Tests"},{"location":"Sorting/insertion_sort/","text":"Builds the final sorted list one item at a time, taking each element from the input list and inserting it into its correct position within the already sorted part of the list. Implementation Usage List<int> result = new[] { 5, 4, 3, 2, 1 }.InsertionSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.InsertionSort(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *InsertionSort* Tests","title":"Insertion"},{"location":"Sorting/insertion_sort/#implementation","text":"","title":"Implementation"},{"location":"Sorting/insertion_sort/#usage","text":"List<int> result = new[] { 5, 4, 3, 2, 1 }.InsertionSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.InsertionSort();","title":"Usage"},{"location":"Sorting/insertion_sort/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *InsertionSort*","title":"Benchmarks"},{"location":"Sorting/insertion_sort/#tests","text":"","title":"Tests"},{"location":"Sorting/merge_sort/","text":"Divides the input list into smaller lists, sorts those smaller lists, and then merges them back together in a sorted manner. Implementation Usage List<int> result = new[] { 5, 4, 3, 2, 1 }.MergeSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.MergeSort(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *MergeSort* Tests","title":"Merge"},{"location":"Sorting/merge_sort/#implementation","text":"","title":"Implementation"},{"location":"Sorting/merge_sort/#usage","text":"List<int> result = new[] { 5, 4, 3, 2, 1 }.MergeSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.MergeSort();","title":"Usage"},{"location":"Sorting/merge_sort/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *MergeSort*","title":"Benchmarks"},{"location":"Sorting/merge_sort/#tests","text":"","title":"Tests"},{"location":"Sorting/quick_sort/","text":"Uses a divide-and-conquer strategy by selecting a \"pivot\" element from the list and partitioning the other elements into two sub-lists according to whether they are less than or greater than the pivot. The sub-lists are then sorted recursively. Implementation Usage List<int> result = new[] { 5, 4, 3, 2, 1 }.QuickSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.QuickSort(); Benchmarks dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *QuickSort* Tests","title":"Quick"},{"location":"Sorting/quick_sort/#implementation","text":"","title":"Implementation"},{"location":"Sorting/quick_sort/#usage","text":"List<int> result = new[] { 5, 4, 3, 2, 1 }.QuickSort(); int[] input = new[] { 5, 4, 3, 2, 1 }; input.QuickSort();","title":"Usage"},{"location":"Sorting/quick_sort/#benchmarks","text":"dotnet run --project ./Benchmarks/Benchmarks.csproj -c Release -- --job short --memory --f *QuickSort*","title":"Benchmarks"},{"location":"Sorting/quick_sort/#tests","text":"","title":"Tests"},{"location":"Text/knuth_morris_pratt/","text":"Implementation Usage ulong result = \"a\".KmpSearch(\"b\"); Tests","title":"Knuth Morris Pratt"},{"location":"Text/knuth_morris_pratt/#implementation","text":"","title":"Implementation"},{"location":"Text/knuth_morris_pratt/#usage","text":"ulong result = \"a\".KmpSearch(\"b\");","title":"Usage"},{"location":"Text/knuth_morris_pratt/#tests","text":"","title":"Tests"},{"location":"Text/levenshtein_distance/","text":"Implementation Usage ulong result = \"a\".LevenshteinDistance(\"b\"); Tests","title":"Levenshtein Distance"},{"location":"Text/levenshtein_distance/#implementation","text":"","title":"Implementation"},{"location":"Text/levenshtein_distance/#usage","text":"ulong result = \"a\".LevenshteinDistance(\"b\");","title":"Usage"},{"location":"Text/levenshtein_distance/#tests","text":"","title":"Tests"}]}